<!-- toc -->

本文介绍实际应用中，部署 DOF 项目到生产环境时需要注意的流程和说明。

## 部署优化

### 开启编译缓存

``` shell
php dof compile
```

DOF 部署到生产环境时，基本都要先执行下编译命令，这样可以避免每次请求都编译领域文件和注解，可以减少大量重复计算和文件载入。

### 使用存储缓存

涉及到的环境变量 KEY 为：

``` php
// 启用 ORM 缓存
'ENABLE_ORM_CACHE' => true,

// 设置 ORM 存储的缓存驱动
'ORM_STORAGE_CACHE' => 'memcached',

// 设置领域内默认的缓存驱动
'CACHE_DRIVER' => 'memcached',
```

### 关闭日志文件单一写入

涉及到的环境变量 KEY 为：

``` php 
// 日志文件的记录是否记录到单个文件
'FILE_LOGGING_SINGLE' => false,
```

在繁忙的线上环境，如果使用了文件日志的方式，可能会遇到的问题之一就是多个 php 进程会并发地往同一个文件写日志。

将上面的环境变量配置为 `false`，则日志文件的写入会按 PHP 进程号分开，从而缓解这个问题。

> 此选项在开发环境建议设置为 `true`，以方便调试。

### 膨胀的日志文件

如果是采用文件来记录日志，那么一个隐藏的定时炸弹就是日益膨胀的日志文件，如果不加处理，那么应用服务器的磁盘早晚都会被写满。

DOF 文件日志默认提供归档的功能，将单个日志文件大小超过配置限制（默认 4M）会存放到 `var/log-{PHP_USER}/archive/` 目录下，并按年月日及其多种分类归档。推荐将这个归档目录映射到一个足够大的硬盘，然后外部设置一个定时删除的脚本。这样可以避免对应用服务器的威胁。

## 线上调试

### 日志

``` php
Log::log('debug:test-sth', $context);
```

上面的 `log()` 方法的第一个参数可以自定义，因此可以将不同场景记录到不同的日志存储目标，这样更方便排查问题。

## 调试 HTTP 请求

### 复制请求为 cURL 命令行

各种浏览器、抓包工具都支持将 HTTP 请求复制为 CURL 命令行，没有什么比这个来的更直接，可以复制请求到终端执行，快速检查接口返回情况。

### 调试线上环境

线上环境的调试一般比较难搞，大部分都是通过查日志来找问题，当然前面的复制请求为 cURL 的方式依然适用于快速检查接口返回情况的场景。

有时候，我们在代码里面打印了日志，但是却期望只在某些条件时候触发日志写入，比如只有某个用户 ID 请求的时候才记录日志，这样可以精准定位某个账号的问题，同时也能减少日志文件的大小。

#### 线上环境有 CDN

这种情况，请求线上环境的返回结果可能不是原始的错误信息，如果你有 CDN 源站的 IP，那么你可以将域名直接指向该 IP，以跳过 CDN 直接请求源站。

### Debug Logging 

DOF 框架提供了一个名为 `DebugLogging` 的 PIPE OFB，可以用于当 HTTP 请求包含指定的请求头且请求头值在项目允许的配置中时，就会将日志写到单独的目录。

这样的好处是，可以和请求量非常大的线上流量日志区分开，只查看本次调试请求时的日志内容。

### 调试 HTTP 请求的数据库查询

由于基于 Swoole 作为 Web 容器来运行 PHP 进程的限制和日志记录量过大带来的性能问题，不方便在无任何代价的前提下将 Swoole 请求对象和存储对象之间发生关联，从而在 Swoole 作为 HTTP Server 的情况下无法在日志记录中记录数据库查询的记录，因此当 HTTP 接口开发完成线上之前，最好在 php-fpm 或者 cli-server 的模式下调试下接口的数据库查询情况和是否有缓存穿透。


``` shell
php -t web -S 0.0.0.0:8888
```
